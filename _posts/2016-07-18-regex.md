---
layout: post
category: blog
title: 正则式学习笔记
description: 30分钟学会正则式
---

## 元字符

| 元字符 | 含义 |
|:---- |:---- |
| . | 除换行符之外的所有字符 |
| \b | 成对出现表示单词的开头或结尾 |
| \d | 匹配数字 |
| \s | 匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格 |
| \w | 匹配字母、下划线、数字或汉字 |


## 重复

| pattern | 含义 |  
|:---- |:---- |
| + | 连续匹配1次以上 |
| \* | 连续匹配0次或任意次 |
| ? | 匹配0次或1次 |
| {n} |：连续匹配n次 |
| {n,} |：连续匹配n次或更多 |
| {n,m} |: 最少连续匹配n次，最多连续匹配m次 |

## 限定的字符集

* [aeiou] : 匹配元音字符
* [0-9] : 匹配数字，等同\d
* [a-z0-9A-Z] : 匹配字母、下划线、数字

## 分支条件
exp1|exp2 : 匹配满足正则式exp1或exp2的字符

示例：

* 0\d{2}-\d{8}|0\d{3}-\d{7} ：匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)；

* \(?0\d{2}\)?[- ]?\d{8}|0\d{2}[- ]?\d{8} : 匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔

* \d{5}-\d{4}|\d{5} ：匹配美国的邮政编码

## 分组

(exp){n} : 连续匹配n次子正则式exp

示例：`((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)`：匹配一个ip地址

## 反义

| exp | 含义 |
|:------ |:------ |
| \W |  |
| \S | 匹配不是空白符的字符 |
| \D | 匹配不是数字的字符 |
| \B | 匹配不是开头或结尾的字符 |
| ^x | 匹配不是x的任意字符 |
| ^aeiou | 匹配不是aeiou中任意一个字符的任意字符 |

# 后向引用

**后向引用** 用于重复搜索前面某个分组匹配的文本。

有多个分组时，默认分组给分组编号，编号从1开始，\n表示第n个分组匹配的文本。

(?'name'exp) 或(?<name>exp)指定正则式为exp的分组名为name，使用\kname来获取分组的文本。

使用(?:exp) 来表示分组，不会拥有组号，且不会被捕获到某个组里。

示例：`\b(?<Word>\w+)\b\s+\k<Word>\b 匹配以空白符隔开的一对单词的文本`

## 零点断宽

* (?=exp) : **零宽度正预测先行断言**，它断言自身出现的后面内容能够匹配表达式exp，即获取exp前面的文本

* (?<=) : **零宽度正回顾后发断言**，它断言自身出现的前面内容能够匹配表达式exp，即获取exp后面的文本

示例：

* \b\w+(?=ing)\b 匹配以ing结尾的单词的前面部分(除了ing以外的部分)  

* (?<=\bre)\w+\b会匹配以re开头的单词的后半部分(除了re以外的部分)  

* (?<=\s)\d+(?=\s)匹配以空白符间隔的数字(再次强调，不包括这些空白符)  

## 负向零点断宽

* (?!exp) : **零宽度负预测先行断言**，它断言自身出现的后面内容能够不能匹配表达式exp，即获取exp前面的文本  

* (?<!=) : **零宽度正回顾后发断言**，它断言自身出现的前面内容能够不能匹配表达式exp，即获取exp后面的文本

示例：

* \d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字

* \b((?!abc)\w)+\b匹配不包含连续字符串abc的单词

* (?<=<(\w+)>).*(?=<\/\1>)匹配不包含属性的简单HTML标签内里的内容

## 注释

* 使用语法(?#comment) 来包含注释

示例：`2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)`
	
* 启用“忽略模式里的空白符”选项,使用#来包含注释，从#开始到这一行结尾在实际使用时都被忽略。


```
(?<=    # 断言要匹配的文本的前缀  

    <(\w+)> # 查找尖括号括起来的字母或数字(即HTML/XML标签)  

    )       # 前缀结束  

    .*      # 匹配任意文本  

    (?=     # 断言要匹配的文本的后缀  

    <\/\1>  # 查找尖括号括起来的内容：前面是一个"/"，后面是先前捕获的标签
       
)       # 后缀结束  
```
